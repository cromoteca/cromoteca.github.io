<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Scalable REST APIs - Cromoteca</title>
    <meta name="description" content="Deep dive into API design patterns, authentication strategies, and performance optimization techniques for production systems.">
    <link rel="stylesheet" href="../styles.css">
    <style>
        .post-content {
            max-width: 800px;
            margin: 0 auto;
            padding: var(--spacing-xl) var(--spacing-sm);
        }

        .post-meta {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-gray-border);
        }

        .post-content h1 {
            font-size: 2.5rem;
            color: var(--color-gray-dark);
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .post-content h2 {
            color: var(--color-blue);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        .post-content p {
            line-height: 1.7;
            margin-bottom: var(--spacing-md);
            color: var(--color-text-primary);
        }

        .post-content code {
            background: var(--color-gray-medium);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.9em;
        }

        .post-content pre {
            background: var(--color-gray-dark);
            color: white;
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
            overflow-x: auto;
            margin: var(--spacing-md) 0;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            color: var(--color-blue);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: var(--spacing-lg);
        }

        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="logo-section">
                <img src="../header-cromoteca.svg" alt="Cromoteca Logo" class="logo">
                <div class="brand">
                    <h1 class="site-title">Cromoteca</h1>
                    <p class="tagline">Software in Colors</p>
                </div>
            </div>
        </div>
    </header>

    <main class="main">
        <article class="post-content">
            <a href="../index.html" class="back-link">‚Üê Back to Blog</a>

            <h1>Building Scalable REST APIs</h1>

            <div class="post-meta">
                <div class="post-category blue">
                    <div class="category-dot blue"></div>
                    <span>Technical</span>
                </div>
                <time class="post-date">December 12, 2024</time>
                <span class="post-read-time">8 min read</span>
            </div>

            <p>Building REST APIs that can scale to handle millions of requests requires careful consideration of architecture, design patterns, and implementation details. This guide covers the essential techniques for creating production-ready APIs that perform well under load.</p>

            <h2>API Design Principles</h2>

            <p>Great APIs start with solid design principles:</p>

            <h3>1. RESTful Resource Design</h3>
            <pre><code>// Good: Resource-based URLs
GET    /api/v1/users           // Get all users
GET    /api/v1/users/123       // Get specific user
POST   /api/v1/users           // Create user
PUT    /api/v1/users/123       // Update user
DELETE /api/v1/users/123       // Delete user

// Nested resources
GET    /api/v1/users/123/posts // Get user's posts
POST   /api/v1/users/123/posts // Create post for user</code></pre>

            <h3>2. Consistent Response Format</h3>
            <pre><code>// Success response
{
  "success": true,
  "data": {
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com"
  },
  "meta": {
    "timestamp": "2024-12-12T10:30:00Z",
    "version": "1.0"
  }
}

// Error response
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid email format",
    "details": {
      "field": "email",
      "provided": "invalid-email"
    }
  },
  "meta": {
    "timestamp": "2024-12-12T10:30:00Z",
    "request_id": "abc123"
  }
}</code></pre>

            <h2>Authentication & Authorization</h2>

            <p>Secure your APIs with robust authentication mechanisms:</p>

            <h3>JWT Implementation</h3>
            <pre><code>const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

class AuthService {
    static async login(email, password) {
        const user = await User.findOne({ email });
        if (!user || !await bcrypt.compare(password, user.password)) {
            throw new Error('Invalid credentials');
        }

        const payload = {
            userId: user.id,
            email: user.email,
            role: user.role
        };

        const token = jwt.sign(payload, process.env.JWT_SECRET, {
            expiresIn: '24h',
            issuer: 'your-api',
            audience: 'your-app'
        });

        return { token, user: payload };
    }

    static verifyToken(token) {
        try {
            return jwt.verify(token, process.env.JWT_SECRET);
        } catch (error) {
            throw new Error('Invalid token');
        }
    }
}</code></pre>

            <h3>Middleware for Authentication</h3>
            <pre><code>const authMiddleware = (req, res, next) => {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({
            success: false,
            error: {
                code: 'MISSING_TOKEN',
                message: 'Authentication token required'
            }
        });
    }

    try {
        const token = authHeader.substring(7);
        const decoded = AuthService.verifyToken(token);
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(401).json({
            success: false,
            error: {
                code: 'INVALID_TOKEN',
                message: 'Invalid authentication token'
            }
        });
    }
};</code></pre>

            <h2>Performance Optimization</h2>

            <p>Several techniques can dramatically improve API performance:</p>

            <h3>1. Database Optimization</h3>
            <pre><code>// Use database indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_created_at ON posts(created_at DESC);

// Optimize queries with select specific fields
const getUsers = async (page = 1, limit = 20) => {
    return await User.find()
        .select('id name email created_at') // Only select needed fields
        .limit(limit)
        .skip((page - 1) * limit)
        .sort({ created_at: -1 });
};</code></pre>

            <h3>2. Caching Strategy</h3>
            <pre><code>const Redis = require('redis');
const client = Redis.createClient();

class CacheService {
    static async get(key) {
        try {
            const cached = await client.get(key);
            return cached ? JSON.parse(cached) : null;
        } catch (error) {
            console.error('Cache get error:', error);
            return null;
        }
    }

    static async set(key, data, ttl = 3600) {
        try {
            await client.setex(key, ttl, JSON.stringify(data));
        } catch (error) {
            console.error('Cache set error:', error);
        }
    }

    static async del(key) {
        try {
            await client.del(key);
        } catch (error) {
            console.error('Cache delete error:', error);
        }
    }
}

// Usage in route handler
app.get('/api/v1/users/:id', async (req, res) => {
    const cacheKey = `user:${req.params.id}`;

    // Try cache first
    let user = await CacheService.get(cacheKey);

    if (!user) {
        // Fetch from database
        user = await User.findById(req.params.id);
        if (user) {
            // Cache for 1 hour
            await CacheService.set(cacheKey, user, 3600);
        }
    }

    if (!user) {
        return res.status(404).json({
            success: false,
            error: { code: 'USER_NOT_FOUND', message: 'User not found' }
        });
    }

    res.json({ success: true, data: user });
});</code></pre>

            <h3>3. Rate Limiting</h3>
            <pre><code>const rateLimit = require('express-rate-limit');

// Global rate limiter
const globalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
    message: {
        success: false,
        error: {
            code: 'RATE_LIMIT_EXCEEDED',
            message: 'Too many requests, please try again later'
        }
    }
});

// Strict limiter for auth endpoints
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 5, // Only 5 login attempts per 15 minutes
    skipSuccessfulRequests: true
});

app.use('/api/', globalLimiter);
app.use('/api/v1/auth', authLimiter);</code></pre>

            <h2>Error Handling</h2>

            <p>Comprehensive error handling improves debugging and user experience:</p>

            <pre><code>class APIError extends Error {
    constructor(message, statusCode = 500, code = 'INTERNAL_ERROR') {
        super(message);
        this.statusCode = statusCode;
        this.code = code;
    }
}

// Global error handler middleware
const errorHandler = (error, req, res, next) => {
    let statusCode = 500;
    let code = 'INTERNAL_ERROR';
    let message = 'An unexpected error occurred';

    if (error instanceof APIError) {
        statusCode = error.statusCode;
        code = error.code;
        message = error.message;
    } else if (error.name === 'ValidationError') {
        statusCode = 400;
        code = 'VALIDATION_ERROR';
        message = error.message;
    } else if (error.name === 'CastError') {
        statusCode = 400;
        code = 'INVALID_ID';
        message = 'Invalid resource ID format';
    }

    // Log error for monitoring
    console.error('API Error:', {
        error: error.message,
        stack: error.stack,
        url: req.url,
        method: req.method,
        ip: req.ip,
        userAgent: req.get('User-Agent')
    });

    res.status(statusCode).json({
        success: false,
        error: {
            code,
            message,
            ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
        },
        meta: {
            timestamp: new Date().toISOString(),
            request_id: req.id
        }
    });
};

app.use(errorHandler);</code></pre>

            <h2>API Documentation</h2>

            <p>Use OpenAPI/Swagger for comprehensive documentation:</p>

            <pre><code>/**
 * @swagger
 * /api/v1/users:
 *   get:
 *     summary: Get all users
 *     tags: [Users]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           minimum: 1
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 100
 *           default: 20
 *     responses:
 *       200:
 *         description: List of users
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/User'
 */</code></pre>

            <h2>Testing Strategy</h2>

            <p>Implement comprehensive testing for reliability:</p>

            <pre><code>const request = require('supertest');
const app = require('../app');

describe('Users API', () => {
    describe('GET /api/v1/users', () => {
        it('should return paginated users', async () => {
            const response = await request(app)
                .get('/api/v1/users')
                .query({ page: 1, limit: 10 })
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(Array.isArray(response.body.data)).toBe(true);
            expect(response.body.data.length).toBeLessThanOrEqual(10);
        });

        it('should handle authentication', async () => {
            await request(app)
                .get('/api/v1/users/me')
                .expect(401);

            await request(app)
                .get('/api/v1/users/me')
                .set('Authorization', 'Bearer valid-token')
                .expect(200);
        });
    });
});</code></pre>

            <h2>Conclusion</h2>

            <p>Building scalable REST APIs requires attention to multiple aspects: design, security, performance, and maintainability. Start with solid fundamentals and gradually add optimization as your application grows. Remember to monitor your APIs in production and continuously improve based on real-world usage patterns.</p>
        </article>
    </main>

    <footer class="footer">
        <div class="container">
            <p class="footer-text">&copy; 2025 Luciano Vernaschi. Software in Colors.</p>
        </div>
    </footer>
</body>
</html>